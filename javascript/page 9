## 1.8.5 Prototypes ðŸ“Œ

**Q234. What is a prototype in JavaScript?**
ðŸ‘‰ Answer: A **prototype** is an object that another object **delegates to** for property/method lookups via its internal **`[[Prototype]]`** link. If a property isnâ€™t found on the object, JS looks **up the chain** to its prototype, then that prototypeâ€™s prototype, and so on, until `null`.
ðŸ“Œ Prototype = **fallback storage** for shared behavior.

**Q235. How is an objectâ€™s `[[Prototype]]` set?**
ðŸ‘‰ Answer:

* **Object literal**: `[[Prototype]]` â†’ `Object.prototype`.
* **Array literal**: â†’ `Array.prototype`.
* **Function (callable)**: â†’ `Function.prototype`.
* **`new Ctor()`**: â†’ `Ctor.prototype`.
* **`Object.create(proto)`**: explicitly sets it.
  ðŸ“Œ Prefer **`Object.create`** or **`class`/`extends`**; avoid mutating later.

**Q236. `prototype` vs `__proto__` vs `[[Prototype]]`â€”whatâ€™s the difference?**
ðŸ‘‰ Answer:

* **`[[Prototype]]`**: the hidden internal link.
* **`obj.__proto__`**: historic accessor to `[[Prototype]]` (use **`Object.getPrototypeOf`** / **`Object.setPrototypeOf`** instead).
* **`Func.prototype`**: the object used as **`[[Prototype]]`** for **instances created with `new Func()`**.
  ðŸ“Œ Donâ€™t confuse **functionâ€™s `.prototype`** with **instanceâ€™s `__proto__`**.

**Q237. How does property lookup work with the prototype chain?**
ðŸ‘‰ Answer: Read: **search own props â†’ walk prototypes**. Write: if you assign to a **new** property name, it **creates an own property** (shadowing). If a **setter** exists on the chain, it may intercept.

```js
const base = { a:1 };
const obj = Object.create(base);
obj.a;        // 1 (from base)
obj.a = 2;    // shadows base.a
```

ðŸ“Œ Use `hasOwnProperty`/`Object.hasOwn` to distinguish own vs inherited.

**Q238. How do you create a â€œdictionaryâ€ without prototype pollution?**
ðŸ‘‰ Answer:

```js
const dict = Object.create(null);  // no Object.prototype
dict.toString; // undefined (safe)
```

ðŸ“Œ Great for **plain key-value** maps without inherited keys.

**Q239. What is property shadowing?**
ðŸ‘‰ Answer: Defining an **own property** with the same name as one on the prototype **hides** (shadows) the inherited one during lookup.
ðŸ“Œ Deleting the own property reveals the inherited again.

**Q240. Should I change prototypes at runtime? (`Object.setPrototypeOf`)**
ðŸ‘‰ Answer: Avoidâ€”itâ€™s **slow** and can deoptimize engines. Prefer constructing objects with the **correct prototype** (`Object.create`, `class`) from the start.
ðŸ“Œ Prototype is best treated as **immutable** post-creation.

**Q241. How do I test for presence correctlyâ€”own vs anywhere?**
ðŸ‘‰ Answer:

* Own only: `Object.hasOwn(obj, "k")` or `obj.hasOwnProperty("k")`.
* Anywhere on the chain: `"k" in obj`.
  ðŸ“Œ Use the right check to avoid **false assumptions**.

---

## 1.8.6 `Object.freeze()` vs `Object.seal()`

**Q242. Whatâ€™s the difference between `freeze`, `seal`, and `preventExtensions`?**
ðŸ‘‰ Answer:

* **`Object.preventExtensions(o)`**: canâ€™t **add** new props.
* **`Object.seal(o)`**: preventExtensions **+** canâ€™t **delete** props; existing props stay writable.
* **`Object.freeze(o)`**: seal **+** make **all data props non-writable** (deep values still mutable).
  ðŸ“Œ All are **shallow**.

**Q243. How do I check these states?**
ðŸ‘‰ Answer:

```js
Object.isExtensible(o); // false â†’ prevented
Object.isSealed(o);     // true  â†’ sealed
Object.isFrozen(o);     // true  â†’ frozen
```

**Q244. Do `freeze`/`seal` affect arrays?**
ðŸ‘‰ Answer: Yesâ€”arrays are objects.

* **Seal**: canâ€™t change length by deleting indices, but can **overwrite existing indices**.
* **Freeze**: cannot change elements, length, or descriptors.
  ðŸ“Œ Methods that mutate (e.g., `push`) will **fail** (or throw in strict mode) on frozen arrays.

**Q245. How to â€œdeep-freezeâ€ an object?**
ðŸ‘‰ Answer: Recursively freeze nested objects you care about:

```js
function deepFreeze(o){
  Object.freeze(o);
  for (const v of Object.values(o))
    if (v && typeof v === "object" && !Object.isFrozen(v)) deepFreeze(v);
  return o;
}
```

ðŸ“Œ Beware of **cycles** (track visited).

**Q246. When should I use `freeze` or `seal`?**
ðŸ‘‰ Answer:

* Use **`freeze`** for **immutable config/state** at runtime.
* Use **`seal`** for **stable shape** while allowing value updates.
  ðŸ“Œ In apps, consider **persistent/immutable** libs or **`structuredClone`** + copy-on-write patterns.

---

## 1.9.1 Prototype Inheritance and Chain

**Q247. How do I set up inheritance with constructor functions (ES5 style)?**
ðŸ‘‰ Answer:

```js
function Animal(n){ this.n = n; }
Animal.prototype.speak = function(){ return this.n + "..." };

function Dog(n){ Animal.call(this, n); }             // 1) call parent ctor
Dog.prototype = Object.create(Animal.prototype);     // 2) link prototypes
Dog.prototype.constructor = Dog;                     // 3) fix constructor
Dog.prototype.speak = function(){ return Animal.prototype.speak.call(this) + " woof"; }
```

ðŸ“Œ Three steps: **call**, **link**, **restore constructor**.

**Q248. How does `class`/`extends` express the same thing?**
ðŸ‘‰ Answer:

```js
class Animal { constructor(n){ this.n = n; } speak(){ return `${this.n}...`; } }
class Dog extends Animal { speak(){ return super.speak() + " woof"; } }
```

ðŸ“Œ `extends` builds the **same prototype chain**; `super` for parent access.

**Q249. How do I inspect the chain?**
ðŸ‘‰ Answer:

```js
Object.getPrototypeOf(dog) === Dog.prototype;                    // instance â†’ class prototype
Object.getPrototypeOf(Dog.prototype) === Animal.prototype;       // subclass â†’ parent
Animal.prototype.isPrototypeOf(dog);                             // true
```

ðŸ“Œ `isPrototypeOf` checks membership **anywhere** in the chain.

**Q250. What pitfalls exist with shared mutable state on prototypes?**
ðŸ‘‰ Answer: Donâ€™t put **mutable objects** (e.g., arrays) on prototypes, or all instances will **share** them.

```js
function C(){ }
C.prototype.items = [];    // BAD: shared
```

ðŸ“Œ Put per-instance state on `this` inside the **constructor**.

**Q251. How do I call a â€œsuper methodâ€ without classes?**
ðŸ‘‰ Answer: Use parent prototype method with **`call`**:

```js
Child.prototype.method = function(){
  Parent.prototype.method.call(this);    // super
  // child work...
};
```

ðŸ“Œ Mirrors `super.method()` semantics.

**Q252. Can I mix prototypes with composition?**
ðŸ‘‰ Answer: Yesâ€”inherit for the **is-a** core, and **mix in** capabilities with `Object.assign` or factories.
ðŸ“Œ Donâ€™t overuse inheritance; **favor composition** for optional features.

---

## 1.9.2 Array Methods: `map`, `reduce`, `filter`, `forEach` ðŸ“Œ

**Q253. What are the core differences between `forEach`, `map`, `filter`, and `reduce`?**
ðŸ‘‰ Answer:

* **`forEach`**: iterate with **side effects**; returns **`undefined`**.
* **`map`**: **transform** each element; returns **same-length** array.
* **`filter`**: **select** elements by predicate; returns **subset**.
* **`reduce`**: **accumulate** to a single value (or any shape).
  ðŸ“Œ Prefer **pure callbacks** (no mutations) for predictability.

**Q254. Can I `break` out of `forEach`?**
ðŸ‘‰ Answer: No. Use a plain `for`/`for...of`, or methods that short-circuit: **`some`** (stops on `true`) or **`every`** (stops on `false`).

```js
if (arr.some(x => x > 10)) { /* found */ }
```

**Q255. How do these methods handle sparse arrays (holes)?**
ðŸ‘‰ Answer: `map`, `filter`, `forEach`, `reduce` **skip holes** (donâ€™t call the callback for missing indices).

```js
const a = [ , 1, , 2 ];
a.map(x => x ?? 0); // [ , 1, , 2 ] â†’ callbacks only for present indices
```

ðŸ“Œ If you need to treat holes as values, **normalize** first.

**Q256. What are common `reduce` patterns (and initial value pitfalls)?**
ðŸ‘‰ Answer: Always provide an **initial value** to avoid edge cases on empty arrays. Patterns:

```js
// sum
arr.reduce((acc, x) => acc + x, 0);

// groupBy
arr.reduce((acc, x) => ((acc[x.type] ??= []).push(x), acc), {});

// indexBy id
arr.reduce((acc, x) => (acc[x.id] = x, acc), {});
```

ðŸ“Œ Without an initial value, reduce uses the **first present element** as `acc`.

**Q257. Map vs chain (mapâ†’filter) vs single `reduce`â€”performance?**
ðŸ‘‰ Answer: One `reduce` can fuse work, but modern engines optimize well; prefer **clarity**. If arrays are **huge/hot paths**, consider **fusion** or **transducers**.
ðŸ“Œ Micro-opt only after measuring.

**Q258. Do these callbacks run async? Can I `await` inside?**
ðŸ‘‰ Answer: They are **synchronous**. Using `async` makes the callback return a **promise**, which `map/filter/reduce` **wonâ€™t await**.

```js
// WRONG for sequencing
arr.map(async x => await fetch(x));
// RIGHT: Promise.all
await Promise.all(arr.map(x => fetch(x)));
```

ðŸ“Œ For sequential async, use a **for...of with await** or **reduce with awaits** carefully.

**Q259. How to avoid unintended mutations with array transforms?**
ðŸ‘‰ Answer: Treat inputs as **immutable**: use `map/filter/reduce` to build **new arrays**; for sorted views: `arr.slice().sort(...)`.
ðŸ“Œ Mutators: `push/pop/shift/unshift/splice/sort/reverse/fill/copyWithin`â€”use on **copies** unless mutation is intended.
