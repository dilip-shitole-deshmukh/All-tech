Awesome 🚀 We’ll speed up and cover **\~30–35 Q\&A per chunk** while keeping answers deep enough for interviews.
We stopped at **Q478 (CSSOM)** → Now we move through **Stage 4 (3.x: Tooling, APIs, Rendering, Optimization)**.

---

## 3.1 Tooling

**Q479. What are ES modules and how do `import`/`export` work? 📌**
👉 Answer: ES modules allow **file-level scoping** and explicit exports/imports.

* `export` shares values.
* `import` pulls them into another file.

```js
// math.js
export function add(a,b){ return a+b; }
// main.js
import { add } from './math.js';
```

📌 Benefits: tree-shaking, async loading, better dependency management.

---

**Q480. Difference between named export, default export, and re-export?**
👉 Answer:

* **Named**: `export const foo=1; import {foo} from './m'`.
* **Default**: `export default fn; import fn from './m'`.
* **Re-export**: `export * from './other.js'`.
  📌 Default for single main API; named for multiple utilities.

---

**Q481. How do bundlers (Webpack, Parcel, Vite) help developers?**
👉 Answer: They:

* Bundle many files into fewer optimized ones.
* Transpile (Babel, TypeScript).
* Optimize assets (minify, tree-shake).
* Enable dev servers with hot reload.
  📌 Critical for production builds.

---

**Q482. What is Babel and why use it?**
👉 Answer: A transpiler that converts modern JS (ES6+) → older ES5 for browser compatibility.

```bash
babel src --out-dir lib --presets=@babel/preset-env
```

📌 Ensures code runs everywhere.

---

**Q483. What is code splitting and why is it important? 📌**
👉 Answer: Splitting bundles into smaller chunks so apps load only what’s needed.

* Example: Lazy-load routes/components in React/Angular.

```js
const Page = React.lazy(()=>import('./Page'));
```

📌 Improves initial load time.

---

**Q484. What is lazy loading vs prefetching?**
👉 Answer:

* **Lazy loading**: Load only when needed (on demand).
* **Prefetching**: Load ahead of time (in background) for likely use.
  📌 Combine both for optimal performance.

---

## 3.2 API Communication

**Q485. What are REST APIs? 📌**
👉 Answer: REST = **Representational State Transfer**. Principles:

* Resources identified by URLs.
* Use HTTP methods: GET, POST, PUT, DELETE.
* Stateless: server doesn’t remember client session.
  📌 Simple, widely adopted.

---

**Q486. Difference between REST and GraphQL?**
👉 Answer:

* REST: Multiple endpoints, fixed responses.
* GraphQL: Single endpoint, client specifies fields.
  📌 GraphQL reduces overfetching, but adds complexity.

---

**Q487. How do you secure API calls in frontend apps?**
👉 Answer:

* Use **HTTPS**.
* Use **tokens (JWT, OAuth)** instead of cookies when possible.
* Avoid storing secrets in frontend.
* Set proper **CORS**.
  📌 Never expose API keys in client code.

---

**Q488. How to validate inputs before API calls?**
👉 Answer:

* Client-side: form validation (required, type checks).
* Server-side: always revalidate (security).
  📌 Prevents XSS/SQL injection.

---

**Q489. How to avoid vulnerabilities in API calls?**
👉 Answer:

* Use **parameterized queries** server-side.
* Sanitize all input.
* Escape output.
* Use rate-limiting + auth.
  📌 Defense-in-depth is key.

---

## 3.3 Rendering & Optimization

**Q490. What is Client-Side Rendering (CSR)? 📌**
👉 Answer: The browser loads a minimal HTML + JS bundle, then JS renders content dynamically.
📌 Pros: rich interactivity. Cons: slower first paint, SEO issues.

---

**Q491. What is Server-Side Rendering (SSR)? 📌**
👉 Answer: HTML is rendered on the server, sent fully formed to client, then hydrated with JS.
📌 Pros: faster first paint, SEO-friendly. Cons: server load.

---

**Q492. CSR vs SSR—when to use each?**
👉 Answer:

* **CSR**: dashboards, apps where SEO not critical.
* **SSR**: e-commerce, blogs, landing pages needing SEO.
  📌 Many frameworks support hybrid (Next.js, Nuxt).

---

**Q493. What is hydration in SSR?**
👉 Answer: The process where server-rendered HTML is “activated” with client-side JS so it becomes interactive. 📌 Can be slow for very large pages.

---

**Q494. What are optimization techniques for frontend performance?**
👉 Answer:

* Minify, compress, cache assets.
* Use CDN.
* Lazy load images/components.
* Code split bundles.
* Debounce/throttle events.
* Use `requestAnimationFrame` for animations.
  📌 Measure with Lighthouse/DevTools.

---

**Q495. What is tree shaking?**
👉 Answer: Removing unused exports during bundling.

```js
// unused function gets dropped
export function unused(){}
export function used(){}
```

📌 Works only with ES modules (static analysis).

---

**Q496. How do Source Maps help debugging?**
👉 Answer: They map minified/transpiled code back to original source for debugging.
📌 Always disable in production if they expose sensitive code.

---

## 3.4 Profiling & Performance

**Q497. How do you profile memory leaks in Chrome DevTools?**
👉 Answer: Use **Performance > Memory** panel:

* Take heap snapshots.
* Look for growing retained objects.
* Check detached DOM nodes.
  📌 Iteratively reproduce leaks and track down.

---

**Q498. What are performance bottlenecks in JS apps?**
👉 Answer:

* Too many DOM manipulations.
* Large bundle size.
* Blocking scripts/styles.
* Long-running synchronous loops.
* Memory leaks.
  📌 Optimize critical rendering path.

---

**Q499. How do you optimize React app performance?**
👉 Answer:

* Use **React.memo** to avoid re-renders.
* Code-split heavy routes.
* Use virtualization for large lists.
* Avoid inline functions in hot paths.
  📌 Profile with React DevTools.

---

**Q500. What is a flame chart in DevTools?**
👉 Answer: A visualization of function execution over time. Wide = long-running function. 📌 Helps find bottlenecks in JS execution.

---

## 3.5 Patterns

**Q501. What is the Module Pattern?**
👉 Answer: Encapsulating private variables with closures, exposing only a public API.

```js
const counter=(function(){
  let c=0;
  return { inc:()=>++c, get:()=>c };
})();
```

📌 Pre-ES6 way of modularization.

---

**Q502. What is the Singleton Pattern?**
👉 Answer: Ensures only **one instance** of an object exists.

```js
class DB { constructor(){ if(DB.instance) return DB.instance; DB.instance=this; } }
```

📌 Useful for config, caches, DB connections.

---

**Q503. What is the Observer Pattern?**
👉 Answer: A subject maintains a list of observers and notifies them on state change.

```js
class Subject{ observers=[]; subscribe(fn){this.observers.push(fn);} notify(v){this.observers.forEach(fn=>fn(v));} }
```

📌 Foundation of event systems, RxJS.

---

## 3.6 Testing & Debugging

**Q504. How do you test JS code with Jest?**
👉 Answer: Jest is a unit testing framework.

```js
test("adds numbers",()=>{ expect(1+2).toBe(3); });
```

📌 Supports mocking, snapshots, async testing.

---

**Q505. How do you debug with Chrome DevTools?**
👉 Answer: Use breakpoints, step through code, inspect variables, watch expressions, profile memory/CPU. 📌 Also use `debugger;` statement.

---

**Q506. What is the difference between unit, integration, and E2E tests?**
👉 Answer:

* Unit: small, isolated functions.
* Integration: multiple modules together.
* E2E: simulate real user flow in browser.
  📌 All are needed for confidence.

---

✅ That’s **Q479–Q506 (28 Q\&A)** covering:

* Tooling (modules, bundlers, Babel, code splitting)
* API communication (REST, security, validation)
* Rendering (CSR, SSR, hydration)
* Performance profiling
* Design patterns
* Testing & debugging

---

Next chunk: **3.5.3 File Organization → 3.7.5 IndexedDB (Stage 5 + Stage 6 Bonus Topics)**.

Do you want me to **finish all remaining topics in 2–3 big chunks (each \~35 Q\&A)** so we close the full 400+ set quickly?
